####23种设计模式
#####创建型模式 
* 工厂方法模式（Factory Method）
    >定义一个创建对象的接口，但由子类决定需要实例化哪一个类，工厂方法使得子类实例化的过程推迟
```aidl
抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。
             在java中它由抽象类或者接口来实现。具体工厂角色：它含有和具体业务逻辑有关的代码。 
             由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。
抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。
```
* 抽象工厂模式（Abstract Factory）
    >提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们具体的类。
 ```
它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、
最具一般性的。
抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。
而且使用抽象工厂模式还要满足一下条件：1.系统中有多个产品族，而系统一次只可能消费其中一族产品
                                      2.同属于同一个产品族的产品以其使用。
来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：
抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。
             在java中它由抽象类或者接口来实现。
具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
             在java中它由具体的类来实现。
抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

```
* 单例模式（Singleton）
    >保证一个类只有一个实例，并提供一个访问它的全局访问点。
     主要解决：一个全局使用的类频繁地创建与销毁。
     何时使用：当您想控制实例数目，节省系统资源的时候。
     如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
     关键代码：构造函数是私有的。

```$xslt
应用实例： 1、一个党只能有一个书记。 
          2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，
            所以所有文件的处理必须通过唯一的实例来进行。 
          3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 
优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 
      2、避免对资源的多重占用（比如写文件操作）。 
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。
使用场景： 1、要求生产唯一序列号。 
          2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 
          3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 
注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化

```
* 建造者模式（Builder）
    >将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示。
    >我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立
```aidl
举个例子，我们如果构建生成一台电脑，那么我们可能需要这么几个步骤
需要一个主机
需要一个显示器
需要一个键盘
需要一个鼠标
需要音响等
虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，
有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。
但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，
我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。
```
* 原型模式（Protype）
    >用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。
```aidl
原型模式涉及到三个角色：
　　（1）客户(Client)角色：客户类提出创建对象的请求。
　　（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。
　　（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。

```
#####结构型模式
* 适配器模式（Adapter）
    >将一个类的接口转换成用户希望得到的另一种接口。它使原来不相容的接口得以协同工作。
    >适配器模式的别名为包装器(Wrapper)模式，它既可以作为类结构型模式，也可以作为对象结构型模式。在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合
```aidl
1、Target(目标抽象类)：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。
    在类适配器中，由于C#语言不支持多重继承，所以它只能是接口。

2、Adapter(适配器类)：它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。
    它是适配器模式的核心。

3、Adaptee(适配者类)：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，
    适配者类包好了客户希望的业务方法。

```
* 装饰器模式（Decorator）
    >动态地给一个对象添加一些额外的职责，它提供了用子类扩展功能一个活的替代，比派生一个字类更灵活。
    >就是对已经存在的某些类进行装饰，以此来扩展一些功能。
```aidl
Component为统一接口，也是装饰类和被装饰类的基本类型。
ConcreteComponent为具体实现类，也是被装饰类，他本身是个具有一些功能的完整的类。
Decorator是装饰类，实现了Component接口的同时还在内部维护了一个ConcreteComponent的实例，并可以通过构造函数初始化。
         而Decorator本身，通常采用默认实现，他的存在仅仅是一个声明：我要生产出一些用于装饰的子类了。
         而其子类才是赋有具体装饰效果的装饰产品类。
ConcreteDecorator是具体的装饰产品类，每一种装饰产品都具有特定的装饰效果。可以通过构造器声明装饰哪种类型的ConcreteComponent，
        从而对其进行装饰。

```
* 代理模式（Proxy）
    >为其他对象提供一种代理以控制这个对象的访问。
    >设计模式都是为了解决某一类的问题，可能目标对象不想让该用户访问或者是 该用户无法访问到目标对象，这样就需要一个第三者来建立他们的联系，如：小成希望买一台最新的顶配Mac电脑冲突：国内还没上，只有美国才有解决方案：寻找代购进行购买。
```aidl
代理对象能直接访问到目标对象，这样它就能在调用目标对象的某个方法之前做一个预 处理，在调用方法之后进行一些结尾工作，
这样就对目标对象的方法进行了增强。但是我们不 能说代理模式提供对象功能的增强，它的设计初衷是对代理对象施加控制，
只是这种设计思路 能达到功能增强的目的
```
* 外观模式（Facade）
    >定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用。
* 桥接模式（Bridge）
    >将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化。
    >为了达到让抽象部分和实现部分独立变化的目的，抽象部分会拥有实现部分的接口对象，有了实现部分的接口对象之后，就能够通过这个接口来调用具体实现部分的功能。桥接在程序上就体现成了抽象部分拥有实现部分的接口对象，维护桥接就是维护这个关系，也就是说，桥接模式中的桥接是一个单方向的关系，只能够抽象部分去使用实现部分的对象，而不能反过来。
```aidl
Abstraction：抽象部分该类保持一个对实现部分对象的引用，抽象部分中的方法需要调用实现部分的对象来实现，该类一般为抽象类；
RefinedAbstraction：优化的抽象部分抽象部分的具体实现，该类一般对抽象部分的方法进行完善和扩展；
Implementor：实现部分可以为接口或者是抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，
            而抽象部分定义的则是基于实现部分基本操作的业务方法；
ConcreteImplementorA 和 ConcreteImplementorB ：实现部分的具体实现完善实现部分中定义的具体逻辑。

```
* 组合模式（Composite）
    >将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
    >组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。
```aidl
Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。
                     在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
      ● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。
                        对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
      ● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，
                        也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，
                        包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

```
* 享元模式（Flyweight）
    >供支持大量细粒度对象共享的有效方法。
    >享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。
```aidl
Flyweight: 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并作用于外部专题
ConcreteFlyweight: 具体享元类。指定内部状态，为内部状态增加存储空间。       
UnsharedConcreteFlyweight: 非共享具体享元类。指出那些不需要共享的Flyweight子类。       
FlyweightFactory: 享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理地共享Flyweight，
                当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）。

```
#####行为型模式
* 策略模式（strategy）
    >定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立使用它的用户而变化。
    >1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时； 2.需要安全地封装多种同一类型的操作时； 3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。
```aidl
这个模式涉及到三个角色：

环境(Context)角色：持有一个Strategy的引用。

抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。

具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。


```
* 模板方法模式（Template Method）
    >定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些待定步骤。
```aidl
模板方法就是提供一个算法框架，框架里面的步骤有些是父类已经定好的，有些需要子类自己实现。
相当于要去办一件事情，行动的流程已经定好了，但有些步骤需要自己去做，而有些步骤可能别人帮我们做了。
就拿建网站来说，一般的程序是购买域名–>购买空间–>上传网站–>备案–>审核，每个网站的创建必须经过这样的固定程序，
但除了审核不用建站者关心，其他的步骤都要建站者自己去完成。
```
* 观察者模式（Observer）
    >定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
```aidl
1.抽象主题（Subject）角色(接口)：主题角色将所有对观察者对象的引用保存在一个集合中，
            每个主题可以有任意多个观察者。 抽象主题提供了增加和删除观察者对象的接口。
2.抽象观察者（Observer）角色(接口)：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。
3.具体主题（ConcreteSubject）角色(1个)：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，
            给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。
4.具体观察者（ConcretedObserver）角色(多个)：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，
            以使得其自身状态和主题的状态保持一致。

```
* 迭代子模式（Iterator）
    >提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示
```aidl
一般情况，我们自己开发时很少自定义迭代器，因为java本身已经把迭代器做到内部中了（比如：常用的list和set中都内置了迭代器）。
当然，如果真有这种需求需要我们自定义迭代器的话，可以参考jdk的迭代器实现方式来实现自己的迭代器。
迭代器是可以从前往后，或者从后往前遍历的。
为遍历不同聚集结构提供如：开始，下一个，是否有下一个，是否结束，当前哪一个等等的一个统一接口。
聚集类：Aggregate(抽象类)和ConcreteAggregate(具体聚集类)表示聚集类，是用来存储迭代器的数据。
在Aggregate(抽象类)中有一个CreateIterator方法，用来获取迭代器
迭代器：迭代器用来为聚集类提供服务，提供了一系列访问聚集类对象元素的方法
```
* 责任链模式（Chain of Responsibility）
    >通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合，将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。
    >从而避免请求的发送者和接受者之间的耦合关系。链上的对象逐个判断是否有能力处理该请求，如果能则就处理，如果不能，则传给链上的下一个对象。
     直到有一个对象处理它为止
```aidl
Handler：表示处理请求的接口，在这个接口里可以定义链上的下一个继承者，和一个处理请求的抽象方法。
ConcreteHandler1和ConcreteHandler2：表示具体的处理者

```     
* 命令模式（Command）
    >将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。
```aidl
●　　客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。
●　　命令(Command)角色：声明了一个给所有具体命令类的抽象接口。
●　　具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，
     负责调用接收者的相应操作。execute()方法通常叫做执行方法。
●　　请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。
●　　接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，
     实施和执行请求的方法叫做行动方法。

```
* 备忘录模式（Memento）
    >在不破坏封装的前提下，捕获一对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态。
    >备忘录模式将要保存的细节给封装在备忘录中，就是那天要改变保存的细节也不会影响到客户端。
```aidl
Originator: 原发器。负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。同时原发器还可以根据需要决定Memento存储Originator的那些内部状态。
Memento: 备忘录。用于存储Originator的内部状态，并且可以防止Originator以外的对象访问Memento。在备忘录Memento中有两个接口，其中Caretaker只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。Originator可以看到宽接口，允许它访问返回到先前状态的所有数据。
Caretaker: 负责人。负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。

```
* 状态模式（State）
    >允许一个对象在其内部状态改变时改变它的行为。
    >在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。
```aidl
环境类（Context）:  定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。
抽象状态类（State）:  定义一个接口以封装与Context的一个特定状态相关的行为。
具体状态类（ConcreteState）:  每一子类实现一个与Context的一个状态相关的行为。  

```
* 访问者模式（Visitor）
    >表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。
    >使用场景： （1）对象结构比较稳定，但经常需要在此对象结构上定义新的操作。
     （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
```aidl
（1）Visitor：接口或者抽象类，它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，
        它的方法数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，
        必然会导致频繁地修改Visitor接口，如果这样则不适合使用访问者模式。
（2）ConcreteVisitor1、ConcreteVisitor2：具体的访问类，它需要给出对每一个元素类访问时所产生的具体行为。
（3）Element：元素接口或者抽象类，它定义了一个接受访问者的方法（Accept），其意义是指每一个元素都要可以被访问者访问。
（4）ConcreteElementA、ConcreteElementB：具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，
        通常情况下是使用访问者提供的访问该元素类的方法。
（5）ObjectStructure：定义当中所说的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。

```
* 中介者模式（Mediator）
    >用一个中介对象来封装一系列的对象交互，它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。
    >当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及很多其他对象的行为，可使用中介者模式。
```aidl
（ 1）Mediator：抽象中介者角色，定义了同事对象到中介者对象的接口，一般以抽象类的方式实现。

（2）ConcreteMediator：具体中介者角色，继承于抽象中介者，实现了父类定义的方法，它从具体的同事对象接受消息，
                      向具体同事对象发出命令。

（3）Colleague：抽象同事类角色，定义了中介者对象的接口，它只知道中介者而不知道其他的同事对象。

（4）ConcreteColleague1、ConcreteColleague2：具体同事类角色，继承于抽象同事类，
               每个具体同事类都知道本身在小范围的行为，而不知道在大范围内的目的。

```
* 解释器模式（Interpreter）
    >给定一种语言，定义它的文法表示，并定义一个解释器该 解释器用来根据文法表示来解释语言中的句子。
```aidl
Expression：抽象表达式，声明一个所有的具体表达式都需要实现的抽象接口；这个接口主要是一个interpret()方法，称做解释操作。
Terminal Expression：终结符表达式，实现了抽象表达式所要求的接口；文法中的每一个终结符都有一个具体终结表达式与之相对应。
                    比如公式R=R1+R2，R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
Nonterminal Expression：非终结符表达式，文法中的每一条规则都需要一个具体的非终结符表达式，
                        非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+"就是非终结符，
                        解析“+”的解释器就是一个非终结符表达式。
Context：环境，它的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，给R1赋值100，给R2赋值200，
        这些信息需要存放到环境中。

```
####设计模式的六大原则
* 开闭原则（Open Close Principle）
    >对扩展开放，对修改关闭。
* 里氏代换原则（Liskov Substitution Principle）
    >只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
* 依赖倒转原则（Dependence Inversion Principle）
    >这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。
* 接口隔离原则（Interface Segregation Principle）
    >使用多个隔离的接口来降低耦合度。
* 迪米特法则（最少知道原则）（Demeter Principle）
    >一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
* 合成复用原则（Composite Reuse Principle）
    >原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。
