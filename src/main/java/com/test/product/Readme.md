####23种设计模式
#####创建型模式 
* 工厂方法模式（Factory Method）
    >常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。
* 抽象工厂模式（Abstract Factory）
    >工厂方法模式和抽象工厂模式不好分清楚，他们的区别如下：
 ```
     工厂方法模式：
     一个抽象产品类，可以派生出多个具体产品类。   
     一个抽象工厂类，可以派生出多个具体工厂类。   
     每个具体工厂类只能创建一个具体产品类的实例。
     
     抽象工厂模式：
     多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
     一个抽象工厂类，可以派生出多个具体工厂类。   
     每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。   
         
     区别：
     工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
     工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
     工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 
     
     抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。
     
     对于java来说，你能见到的大部分抽象工厂模式都是这样的：
     ---它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。
     
     比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。
     
     这样A和B就是工厂，对应于抽象工厂；
     每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；
     
     用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法）
     
     所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线
```
* 单例模式（Singleton）
    >单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。
```$xslt
有几个好处：

1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，
肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。
```
* 建造者模式（Builder）
    >利用构建器作为参数来构建Student对象
* 原型模式（Protype）
    >原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象
#####结构型模式
* 适配器模式（Adapter）
    >适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
* 装饰器模式（Decorator）
* 代理模式（Proxy）
* 外观模式（Facade）
* 桥接模式（Bridge）
* 组合模式（Composite）
* 享元模式（Flyweight）
#####行为型模式
* 策略模式（strategy）
* 模板方法模式（Template Method）
* 观察者模式（Observer）
* 迭代子模式（Iterator）
* 责任链模式（Chain of Responsibility）
* 命令模式（Command）
* 备忘录模式（Memento）
* 状态模式（State）
* 访问者模式（Visitor）
* 中介者模式（Mediator）
* 解释器模式（Interpreter）
####设计模式的六大原则
* 开闭原则（Open Close Principle）
    >对扩展开放，对修改关闭。
* 里氏代换原则（Liskov Substitution Principle）
    >只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
* 依赖倒转原则（Dependence Inversion Principle）
    >这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。
* 接口隔离原则（Interface Segregation Principle）
    >使用多个隔离的接口来降低耦合度。
* 迪米特法则（最少知道原则）（Demeter Principle）
    >一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
* 合成复用原则（Composite Reuse Principle）
    >原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。
